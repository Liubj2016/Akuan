<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Akuan : 面白い人間になりたい">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>learn</title>
  </head>

  <body>
      <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/Liubj2016/Akuan">View on GitHub</a>
          <div class="clearfix">
                <ul id="menu" class="drop">
                    <li><a href="http://liubj2016.github.io/Akuan">Home</a></li>
                    <li><a>liubaojie2016@163.com</163></a></li>
                </ul>
            </div>

          <h1 id="project_title">Akuan</h1>
          <h2 id="project_tagline">面白い人間になりたい</h2>

            
        </header>
    </div>

    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
<!-- 以上是需要的头 -->

<div id="wiki-body" class="wiki-body gollum-markdown-content instapaper_body">
<div class="markdown-body">
  <h1>
<a id="user-content-matlab-project-2蒙特卡洛模拟的美式期权" class="anchor" href="#matlab-project-2%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%A8%A1%E6%8B%9F%E7%9A%84%E7%BE%8E%E5%BC%8F%E6%9C%9F%E6%9D%83" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>matlab project 2——蒙特卡洛模拟的美式期权</h1>

<blockquote>
<p>Stock prices sometimes change by large values in short periods of time, making a
jump diffusion model be a more appropriate model to capture this characteristic than a
plain diffusion model. We extend the Black-Scholes to include jumps, resulting in the
following model in risk-neutral world,<br>
<img src="images/project2.png" alt="image"><br>
where Yi ~U(1.1, 1.3) and N(t) is a Poisson process with lambda=4 per year.</p>
</blockquote>

<p><em>其中Z服从标准正态分布。</em></p>

<p>思路如下：  </p>

<ol>
<li>先模拟出每个节点的股票价格S和在此点执行所能得到的收益f；</li>
<li>总共模拟MxN个，M代表M条路径，N代表将一段时间分为N期。用S(n)代表股价的每一列。</li>
<li>如果在S(n)选择执行，即f(n)&gt;0,那么就将f(n+1)与对应的S(n)进行一元二次回归，得到一个模型，系数向量为p；</li>
<li>将S(n)全部代入模型中得到拟合值y；</li>
<li>将f与y进行比较，f&gt;y的值就留下，f&lt;y的值令其为0；</li>
<li>从左往右汇总f，如果某个值所在路径上它是第一个大于0的值，其值有效，否则无效。</li>
</ol>

<p>代码如下（<strong>由于上述步骤中有很多需要判断，这样写代码就会显得很乱而且很长，所以充分利用matlab矩阵运算和逻辑运算简化了代码</strong>）：  </p>

<p>ps：运行代码有彩蛋哦。。（我真无聊(￣、￣)）</p>

<div class="highlight highlight-source-matlab"><pre><span class="pl-k">function</span> [<span class="pl-v">P</span>]=<span class="pl-en">regressionP</span>(<span class="pl-v">M</span>,<span class="pl-v">N</span>)
r=<span class="pl-c1">0.1</span>;
<span class="pl-c1">sigma</span>=<span class="pl-c1">0.1</span>;
S0=<span class="pl-c1">90.44</span>;
K=<span class="pl-c1">110</span>;
T=<span class="pl-c1">3</span>;
lambda=<span class="pl-c1">4</span>;
dt=T/N;
S=<span class="pl-k">zeros</span>(M,N+<span class="pl-c1">1</span>);
S(:,<span class="pl-c1">1</span>)=S0;
f=<span class="pl-k">zeros</span>(M,N+<span class="pl-c1">1</span>);
f(:,<span class="pl-c1">1</span>)=<span class="pl-c1">0</span>;
X=<span class="pl-c1">random</span>(<span class="pl-s"><span class="pl-pds">'</span>poisson<span class="pl-pds">'</span></span>,lambda*dt,M,N);
<span class="pl-c">%下面的循环用来计算股票每个节点的价格以及执行所能得到的收益</span>
<span class="pl-k">for</span> <span class="pl-k">i</span>=<span class="pl-c1">1</span>:M
    <span class="pl-k">for</span> <span class="pl-k">j</span>=<span class="pl-c1">2</span>:N+<span class="pl-c1">1</span>        
        Y=<span class="pl-c1">1.1</span>+<span class="pl-c1">0.2</span>*<span class="pl-k">rand</span>(<span class="pl-c1">1</span>,X(<span class="pl-k">i</span>,<span class="pl-k">j</span>-<span class="pl-c1">1</span>));
        m=<span class="pl-k">prod</span>(Y);
        S(<span class="pl-k">i</span>,<span class="pl-k">j</span>)=S(<span class="pl-k">i</span>,<span class="pl-k">j</span>-<span class="pl-c1">1</span>)*<span class="pl-k">exp</span>((r-<span class="pl-c1">sigma</span>^2/<span class="pl-c1">2</span>)*dt+<span class="pl-c1">sigma</span>*dt^0.5*<span class="pl-k">randn</span>())*m;
        f(<span class="pl-k">i</span>,<span class="pl-k">j</span>)=<span class="pl-k">max</span>(K-S(<span class="pl-k">i</span>,<span class="pl-k">j</span>),<span class="pl-c1">0</span>);
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

P=<span class="pl-c1">0</span>;<span class="pl-c">%初始化期权价格P</span>
y=<span class="pl-k">zeros</span>(M,N-<span class="pl-c1">1</span>);<span class="pl-c">%初始化回归预测值</span>
d=<span class="pl-k">zeros</span>(M,<span class="pl-c1">1</span>);<span class="pl-c">%初始化用来最后计数的值</span>
<span class="pl-k">for</span> <span class="pl-k">i</span>=<span class="pl-c1">2</span>:N
    a=f(:,<span class="pl-k">i</span>+<span class="pl-c1">1</span>);
    b=S(:,<span class="pl-k">i</span>);<span class="pl-c">%储存股票的价格</span>
    W=a(f(:,<span class="pl-k">i</span>)&gt;0)*<span class="pl-k">exp</span>(-r*dt);
    s=b(f(:,<span class="pl-k">i</span>)&gt;0);
    p=<span class="pl-k">polyfit</span>(s,W,<span class="pl-c1">2</span>);<span class="pl-c">%p是回归得到的系数</span>
    y(:,<span class="pl-k">i</span>)=<span class="pl-k">polyval</span>(p,b);
    f(:,<span class="pl-k">i</span>)=f(:,<span class="pl-k">i</span>).*(f(:,<span class="pl-k">i</span>)&gt;y(:,<span class="pl-k">i</span>)*<span class="pl-c1">1</span>);<span class="pl-c">%f矩阵中大于y的留下，小于y的为0</span>
    d=d+(f(:,<span class="pl-k">i</span>)&gt;0)*<span class="pl-c1">1</span>;
    q=f(:,<span class="pl-k">i</span>);<span class="pl-c">%储存f每一列</span>
    P=P+<span class="pl-k">sum</span>(q(d==<span class="pl-c1">1</span>))*<span class="pl-k">exp</span>(-r*dt*(<span class="pl-k">i</span>-<span class="pl-c1">1</span>));<span class="pl-c">%只取每条路径上第一个大于0的f</span>
<span class="pl-k">end</span>
<span class="pl-c">%最后一列没有包含在循环中，单独计算，最后得到美式看跌期权价格P</span>
d=d+(f(:,N+<span class="pl-c1">1</span>)&gt;0)*<span class="pl-c1">1</span>;
q=f(:,N+<span class="pl-c1">1</span>);
P=(P+<span class="pl-k">sum</span>(q(d==<span class="pl-c1">1</span>))*<span class="pl-k">exp</span>(-r*T))/M;
<span class="pl-k">load</span> handel.mat;
<span class="pl-k">sound</span>(y)</pre></div>

</div>
</div>


  <!-- 以下是需要的尾 -->


<hr>
    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Akuan maintained by <a href="https://github.com/Liubj2016">Liubj2016</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>   

  </body>
</html>